
### 影响ABI兼容性的因素

 - **硬件 - 如处理器**：二进制里面包含了指令和数据，而CPU有一个核心作用就是处理指令，不同架构的CPU指令集都不同，从而产生的二进制也会不同，例如你在代码中调用了print函数，最终在X86生成的二进制文件的一条指令是call 0x1234, 但是在ARM处理器下它可能没有call指令，它的跳转指令可能是jar。

 - **操作系统**：不同操作系统的二进制文件格式各不相同，比如windows无法解析linux下的ELF文件格式，从而无法完成可执行文件在执行之前的一系列初始化操作；此外，文件操作、输入输出、内存申请释放、任务调度等都需要用到特定操作系统的特定库，这些库在不同操作系统完全不一样。

 - **编译器**：如C++函数签名，函数签名的目的就是让编译器能够根据对应的签名规则生成一个符号，编译器根据这个符号来识别和处理函数，函数签名包含了一个函数的信息，其中包括函数名、参数类型、参数个数、类名、名称空间。同一代码在gcc和vc编译器生成之后的符号分别为`_Z8Functioni`和`?Function@@YAHH@Z`，函数签名规则都不一样，那gcc编译的库vc++能够找到它的符号吗，答案肯定是不行的。另外，就算是相同版本的gcc也一样可能出现二进制不兼容，如gcc4.9版本C++ string,list符号命名和gcc5.1之后的符号命名都是不同的gcc5.1上会增加__cxx11，所以一样会产生在gcc4.9编译的库，在gcc5.1上使用不了。

 - **语言层面 - C++**：包括内置类型的大小以及对齐方式（如大端、小端）、struct、union、数组等的存储方式和内存分布、函数调用方式，比如参数入栈顺序、返回值如何保持等、堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等、继承类体系的内存分布，如基类、虚基类再继承类中的位置等、指向成员函数的指针的内存分布，如何传递this指针、如何调用虚函数，vtable的内容和分布形式，vtable指针在object中的位置等、templte 如何实例化、外部符号的修饰、全局对象的构造和析构、异常的产生和捕获机制、RTTI如何实现等等。


参考：[细谈ABI (Application Binary interface)](https://juejin.cn/post/6894179449996312589)

---

### C/C++编译随记

编译代码的过程分成 4 个环节，预处理，编译，汇编，链接（生成可执行文件或者库文件），首先我们需要明确几点：

- 头文件只参与预处理环节，跟编译和后续环节没有什么关系。
- 任何一个源文件都是独立编译，相互之间不干扰。
- 前三个环节并不涉及到第三方的库文件，但是在预处理环节会涉及到库的头文件。
- 预处理环节一般不会出错，哪怕你使用了一个未定义的宏，也不会出错，只会在编译时报错，而任何编译错误都不会跟库文件扯上任何关系。
- 汇编一般也不会出错，它只是编译器一个中间的隐性环节，把汇编代码编译成目标代码。
- 链接是天坑，标准库和第三方库的库文件都是在这个环节加入进来的。
- 我们遇到的问题，基本上都是编译出错或者链接出错。然而事情并没有那么简单。

**预处理**：预处理我们接触最多的就是包含头文件的 #include 和定义宏的 #define，同时还有规范性的头文件保护宏。在这个环节出现最多的问题是找不到头文件，然后编译器停止工作。这个问题是最容易被解决的，但是很多人可能并不是很了解编译器寻找头文件的流程。这里我们首先要区分 3 种头文件，第一种是标准库的头文件，第二种是代码中引用到的第三方库的头文件，第三种是自己代码编写的头文件。编译器在工作时是有一个头文件目录列表的，根据目录列表去寻找头文件，第一个目录便是当前代码的所在的目录，其次是编译器自行定义的目录（一般是标准库头文件所在的目录），最后是我们自己在编译时加上的目录列表，可以有多个，包括需要引用的第三方库的头文件目录和自己代码的头文件目录（可能你自己写的头文件跟源文件不在一个目录下）。

**编译与汇编**：编译环节出错那基本就是语法的问题，代码写得有问题直接导致编译器停止工作。这里不得不提一下 C++11 标准，并不是所有编译器都实现了新标准的所有规范，同时可能编译器之间实现的特性还有差异，这些在写跨编译器或跨平台代码事要特别注意，同一个编译器的不同版本之间也会略有差异。

**链接**：链接环节出现问题非常之多，类型也是五花八门，奇奇怪怪，会非常坑。但是归根结底主要是两种，第一是链接时找不到符号，第二是链接时找到了多个符号。很多同学碰到链接出错时编译器吐出来的一堆一堆乱七八糟的函数符号估计都很蛋疼，但是我们多数时候碰到的都是 undefined reference to xxx，即找不到符号。要搞明白链接时编译器是怎么工作的，我们就得先搞清楚 符号 在编译系统中的作用。一个符号可以指代一块内存或者一段代码。代码中与符号相关的几处地方如下：

 - 变量的声明，告诉编译器有这么一个变量指代一块内存。
 - 变量的定义，告诉编译器需要为这个变量分配一块内存。
 - 函数的声明，告诉编译器有这么一段代码可以使用，输入输出规范如何，应该怎么调用。
 - 函数的定义，告诉编译器这段代码的逻辑实现。
 - 引用变量或函数，代码中使用某个变量或者调用某个函数。

编译器会给每个变量和每个函数分配一个符号，这样做的好处是方便符号的重用（函数的重用），也利于项目代码的模块化，多个目标文件的链接。由于每个源文件代码都是独立编译的，并生成目标文件，编译器在处理这个源文件时，最后会在目标文件中指出它所需要的符号和它能够提供的符号，这样，链接器在链接一堆目标文件时（库所提供的目标文件和自己代码的目标文件）就能够为每个待确定的符号找到对应的符号，从而成功生成可执行文件或者库文件。

**C++ 编译器中符号的兼容性**：多数情况下，我们使用的第三方库都是库的提供者事先编译好的，这就带来了一个很大的隐患。同一个函数在库中的符号和我们编译器要寻找的符号可能不一致，这个问题在 MSVC 上尤为突出。除去动态库静态库的差异，针对相同编译器的不同版本，同一个函数可能生成的符号会不一样，这是最最坑爹的地方。看看 OpenCV 里 VC10，VC11，VC12 的各个目录就知道这个差异是非常大的。相对而言，gcc 不同版本之间的兼容性似乎就好很多。当然 C 的代码相对于 C++ 就好很多了，不可能出现这种坑爹的情况。

参考：[Something You Should Kown About C/C++ Compiler](https://luoyetx.github.io/compiler.html)

---

## C和C++混合编程

 - 混编C和C++是C++提供的功能，所以只能在C++代码中想办法。C++编译器允许在声明中带 extern "C" ，表示按照C的方式链接，这样声明的代码可以与C交互。
 - C++中访问C：C++中引用C必须在C的声明中带 extern "C" 。最简单的引用C语言代码的方式，是在C++ 原代码文件中，在包含头文件的地方使用 extern "C"。
 - 如果希望使用C++的方式使用一个C的数据结构，这就需要使用派生。声明一个 C++的类，以C的数据结构为父类，再定义成员函数，在成员函数中直接调用C的操作函数即可。
 - 在C中访问C++：用 extern "C" 声明的函数可以被C访问，C++是支持多态和模板的，同一个函数名可以输入不同的参数类型，但C不能那么做，需要区分函数名才能使用多态或者模板的C++函数。例如，在C++代码中，有一个模板函数f()，要让C语言能访问这个函数，需要重新写几个函数包含它。
 - C访问C++类：要访问C++类，最好的办法是将C++类包含在C的数据结构中，或者在提供C的接口时，使用 void* 来表示对象的类型。也有直接使用的办法，没有多少区别。

参考：[混编C和C++](https://quant67.com/post/C/mix-c-cpp.html)

---

### Linux 系统调用
[Linux 下系统调用的三种方法](https://hazirguo.github.io/articles/2013/three_method_of_syscall.html)

[Linux 内核系统调用详解](https://github.com/MintCN/linux-insides-zh/blob/master/SysCall/linux-syscall-1.md)

[API/ABI changes review for glibc](https://abi-laboratory.pro/index.php?view=timeline&l=glibc)

[如何对遗留 C++ 代码进行现代化改造？](https://www.incredibuild.cn/blog/ruheduiyiliucppdaimajinxingxiandaihuagaizao)

[关于 C++ 依赖管理](https://www.incredibuild.cn/blog/guanyu-cppyilaiguanli)

[C++开发调研 - Jetbrains](https://www.jetbrains.com/zh-cn/lp/devecosystem-2021/cpp/)